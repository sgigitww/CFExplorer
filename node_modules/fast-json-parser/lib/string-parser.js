"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class StringParser {
    constructor() {
        this.state = 0 /* Normal */;
        this.buffer = null;
        this.start = 0;
        this.end = 0;
        this.rest = null;
        this.unicode = 0;
        this.digitCount = 0;
        this.init("", 0);
    }
    init(str, k) {
        this.state = 0 /* Normal */;
        this.buffer = str;
        this.start = this.end = k + 1;
        this.rest = null;
    }
    advance(str, k) {
        switch (this.state) {
            case 0 /* Normal */:
                this.parseNormal(str.charCodeAt(k), k);
                return false;
            case 3 /* Ended */:
                return true;
            case 1 /* Escaped */:
                this.parseEscaped(str.charCodeAt(k), k);
                return false;
            case 2 /* Unicode */:
                this.parseUnicode(str.charCodeAt(k), k);
                return false;
        }
    }
    switchString(str) {
        if (this.buffer !== null) {
            let endOfString = this.state === 3 /* Ended */ ? this.end : this.buffer.length;
            if (this.rest === null) {
                this.rest = this.buffer.substring(this.start, endOfString);
            }
            else {
                this.rest += this.buffer.substring(this.start, endOfString);
            }
        }
        this.buffer = str;
        this.start = this.end = 0;
    }
    parseNormal(code, k) {
        this.end = k;
        if (code === 34 /* Quote */) {
            this.state = 3 /* Ended */;
        }
        else if (code === 92 /* Escape */) {
            this.consolidate();
            this.start = k + 1;
            this.state = 1 /* Escaped */;
        }
    }
    parseEscaped(code, k) {
        if (code === 117 /* U */) {
            this.state = 2 /* Unicode */;
            this.unicode = 0;
            this.digitCount = 0;
        }
        else {
            var char = this.translate(code);
            if (char !== null) {
                // translation found
                this.rest += char;
                this.start = k + 1;
            }
            else {
                // reset as if backslash never existed
                this.start = k;
                this.end = k + 1;
            }
            this.state = 0 /* Normal */;
        }
    }
    parseUnicode(code, k) {
        this.unicode = this.unicode * 16 + (code - 48 /* Zero */);
        if (++this.digitCount === 4) {
            this.state = 0 /* Normal */;
            this.rest += String.fromCharCode(this.unicode);
            this.start = k + 1;
        }
    }
    translate(code) {
        switch (code) {
            case 110 /* N */:
                return "\n";
            case 114 /* R */:
                return "\r";
            case 116 /* T */:
                return "\t";
            case 98 /* B */:
                return "\b";
            case 102 /* F */:
                return "\f";
            default:
                return null;
        }
    }
    consolidate() {
        this.rest = this.currentContent();
    }
    currentContent() {
        if (this.rest === null) {
            return this.buffer.substring(this.start, this.end);
        }
        else if (this.buffer !== null) {
            return this.rest + this.buffer.substring(this.start, this.end);
        }
        else {
            return this.rest;
        }
    }
    value() {
        return this.currentContent(); //JSON.parse(this.currentContent())
    }
}
exports.StringParser = StringParser;
//# sourceMappingURL=string-parser.js.map