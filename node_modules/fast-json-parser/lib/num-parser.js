"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
function isEndOfValue(code) {
    return (code === 44 /* Comma */ ||
        code === 125 /* RBrace */ ||
        code === 93 /* RBracket */ ||
        code === 32 /* Whitespace */ ||
        code === 13 /* Cr */ ||
        code === 10 /* Lf */);
}
class NumParser {
    constructor() {
        this.isNegative = false;
        this.hasExponent = 0 /* None */;
        this.mode = 0 /* Normal */;
        this.whole = 0;
        this.reminder = 0;
        this.exponent = 1;
        this.divisor = 1;
        this.fallbackCharcodes = new Array(64).fill(-1);
        this.fallbackPosition = 0;
    }
    init(code) {
        this.mode = 0 /* Normal */;
        if (code === 45 /* Minus */) {
            this.isNegative = true;
            this.whole = 0;
        }
        else {
            this.isNegative = false;
            this.whole = code - 48 /* Zero */;
        }
        this.reminder = 0;
        this.divisor = 1;
        this.exponent = 0;
        this.hasExponent = 0 /* None */;
        this.fallbackPosition = 0;
        this.fallbackCharcodes[this.fallbackPosition] = code;
    }
    advance(str, k) {
        let code = str.charCodeAt(k);
        switch (this.mode) {
            case 1 /* Reminder */:
                if (code >= 48 /* Zero */ && code <= 57 /* Nine */) {
                    let val = code - 48 /* Zero */;
                    this.reminder = this.reminder * 10 + val;
                    this.divisor *= 10;
                }
                else if (code === 69 /* E */ || code === 101 /* e */) {
                    this.mode = 2 /* ExponentStart */;
                }
                else if (isEndOfValue(code)) {
                    return true;
                }
                else if (code === 46 /* Dot */) {
                    throw new Error(util_1.mkErrorMsg(str, k));
                }
                break;
            case 0 /* Normal */:
                if (code >= 48 /* Zero */ && code <= 57 /* Nine */) {
                    this.whole = this.whole * 10 + (code - 48 /* Zero */);
                }
                else if (code === 46 /* Dot */) {
                    this.mode = 1 /* Reminder */;
                }
                else if (code === 69 /* E */ || code === 101 /* e */) {
                    this.mode = 2 /* ExponentStart */;
                }
                else if (isEndOfValue(code)) {
                    return true;
                }
                else {
                    throw new Error(util_1.mkErrorMsg(str, k));
                }
                break;
            case 2 /* ExponentStart */:
                if (code === 45 /* Minus */)
                    this.hasExponent = 2 /* Negative */;
                else if (code === 43 /* Plus */)
                    this.hasExponent = 1 /* Positive */;
                else if (code >= 48 /* Zero */ && code <= 57 /* Nine */) {
                    this.hasExponent = 1 /* Positive */;
                    this.exponent = code - 48 /* Zero */;
                }
                else {
                    throw new Error(util_1.mkErrorMsg(str, k));
                }
                this.mode = 3 /* ExponentNum */;
                break;
            case 3 /* ExponentNum */:
                if (code >= 48 /* Zero */ && code <= 57 /* Nine */) {
                    this.exponent = this.exponent * 10 + (code - 48 /* Zero */);
                }
                else if (isEndOfValue(code)) {
                    return true;
                }
                else {
                    throw new Error(util_1.mkErrorMsg(str, k));
                }
                break;
        }
        this.fallbackCharcodes[++this.fallbackPosition] = code;
        return false;
    }
    fallback() {
        return Number(String.fromCharCode.apply(String, this.fallbackCharcodes.slice(0, this.fallbackPosition + 1)));
    }
    value() {
        if (this.divisor > 10000000000000 || this.exponent > 323) {
            // Slow path, floating point arithmetic failure
            return this.fallback();
        }
        if (this.hasExponent === 2 /* Negative */)
            this.exponent = 0 - this.exponent;
        let val = this.whole + this.reminder / this.divisor;
        if (this.isNegative)
            val = 0 - val;
        if (this.hasExponent > 0)
            val = val * Math.pow(10, this.exponent);
        else if (this.hasExponent === 2 /* Negative */)
            val = val * Math.pow(10, 0 - this.exponent);
        return val;
    }
}
exports.NumParser = NumParser;
//# sourceMappingURL=num-parser.js.map